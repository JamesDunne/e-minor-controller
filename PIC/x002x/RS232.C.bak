//#######################################################################
/**
* @file rs232.c
* This file contains the various functions required to handle both RS232
* and USB (the vendor defined portion anyway).  
*
* @author Joe Dunne
* @date 2/02/05
* @brief RS232/USB communication routine
*/
//			*See Updates section at bottom of file*
//#######################################################################

#include	"c_system.h"

#include "typedefs.h"
#include "usb.h"



#define	INVALID_REQUEST				0xff
#define	PRODUCTION_TEST_PROTOCOL	0x0003

extern rom struct{byte bLength;byte bDscType;word string[];}PrdString;
extern struct{byte bLength;byte bDscType;word string[];}SerialNum;
extern struct{byte bLength;byte bDscType;word string[];}MfrString;
extern rom struct{byte bLength;byte bDscType;word string[];}DevChem;


void	TXENQ_0xFFFF(void) {		//created to free up code space
	TXENQ(0xff);	//low byte
	TXENQ(0xff);	//high byte
}

void	TXENQ_0x00(void) {			//created to free up code space
	TXENQ(0x00);	//low byte
}

//unsigned char NVR_SINGLE_READ(unsigned char Address) {
//	EEAddress = Address;
//	DISABLE_ALL_INTERRUPTS();
//	return(READ_SYSTEM_NVR());		//returns data through wreg
//}

void	HIDGetReportHandler(void);

//These macros are used to tell how many characters to respond to RS232 set commands with:
#define Echo1Byte()									//this is the default if the other 2 aren't set.
#define Echo2Bytes() CommEcho2Bytes = true;
#define Echo4Bytes() CommEcho4Bytes = true;

//-----------------------------------------------------------------------
//This routine will store a character into the TxBuffer.
void	TXENQ(unsigned char Input) {
	if (!USBQuery) {
		//RS232 Query
		if (TxBufPtr >= MAX_TX_LENGTH) return;		//Exit if buffer full.
		TxBuffer[TxBufPtr] = Input;	//Store value in buffer.
		TxBufPtr++;					//Update input ptr.
	}
	else {
		//USB Query
		if (USBDataPointer >= 8) return;		//Exit if buffer full.
		CtrlTrfData._byte[USBDataPointer] = Input;
		USBDataPointer++;
	}
}

//--------------------------------------------------------------
//						Handle received query
//--------------------------------------------------------------
void	PROCESS_COMM_REQUEST(void) {
	unsigned char *RcvPtr;
	unsigned char tempvar1, tempvar0;
	far unsigned char *Data;
	BitField ByteToSend;

	//default response for no query:
	ResponseType = 0xFF;

	if (!USBQuery) {
		//RS232 query
		ProcessCommRequest = false;
		//Prevent any communication in progress from being messed up.
		if (TxBufPtr != 0) return;
		SendingOutString = false;
		TxBufPtr = 4;			//the header will be written later.
		RcvPtr = (unsigned char *)&RxBuffer[4];
	}
	else {
		//USB query
		USBDataPointer = 1;		//the 0th byte is the reportid
		RcvPtr = (unsigned char *)&USBEP0DataInBuffer[1];
	}

//Polling command:
	if (!USBQuery && RxBuffer[1] == 0x03 || \
		USBQuery && SetupPkt.bRequest == GET_REPORT) {

		//default response for query:
		ResponseType = DATA_RETURNED;

		switch ((USBQuery?SetupPkt._byte[2]:RxBuffer[3])) {
		case 13:
		case 14:
		case 40:
			//iProduct
			TxBuffer[2] = PrdString.bLength/2;			//number of bytes in response
			if (USBQuery) {
				TXENQ(INDEX_NAME);
				break;
			}
			break;
		case 41:
			//iSerialNumber
			TxBuffer[2] = SerialNum.bLength/2;			//number of bytes in response
			if (USBQuery) {
				TXENQ(INDEX_SERIALNUM);
				break;
			}
			break;
		case 98:	//iOEMInformation
		case 43:	//iManufacturer
			TxBuffer[2] = MfrString.bLength/2;			//number of bytes in response
			if (USBQuery) {
				TXENQ(INDEX_MANUFACTURER);
				break;
			}
			break;

		case 42:
			//iDeviceChemistry
			TxBuffer[2] = DevChem.bLength/2;			//number of bytes in response
			if (USBQuery) {
				TXENQ(INDEX_DEVCHEM);
				break;
			}			
			break;

//production test commands:			
		case 150:		//NVR Read
			if (1 && !PIE2bits.EEIE) { 
//				Temp6 = NVR_SINGLE_READ(NVRCommAddr.b_form.low);
//				TXENQ(Temp6);
			}
			else {
				ResponseType = COMMAND_REJECTED;
				TXENQ(INVALID_REQUEST);
			}
			break;
			
		case 151:		//NVR Address
			if (1) { 
//				TXENQ(NVRCommAddr.b_form.low);		//low byte
//				TXENQ(NVRCommAddr.b_form.high);		//high byte
			}
			else {
				ResponseType = COMMAND_REJECTED;
				TXENQ(INVALID_REQUEST);		//low byte
				TXENQ(INVALID_REQUEST);		//high byte
			}
			break;
		case 152:		//RAM Read
			if (1) { 
				Data = (far unsigned char *)RAMCommAddr.s_form;
				TXENQ(*Data);
			}
			else {
				ResponseType = COMMAND_REJECTED;
				TXENQ(INVALID_REQUEST);
			}
			break;

		case 180:		//NVR Page Read
			if (1 && !PIE2bits.EEIE) {
//				DISABLE_ALL_INTERRUPTS();
//				EEAddress = NVRCommAddr.b_form.low;
//				for (tempvar1 = 0;tempvar1<=3;tempvar1++) {
//					Temp6 = READ_SYSTEM_NVR();
//					TXENQ(Temp6);
//					EEAddress++;
//				}
//				break;
			}
			else {
				ResponseType = COMMAND_REJECTED;
				TXENQ(INVALID_REQUEST);
				TXENQ(INVALID_REQUEST);
				TXENQ(INVALID_REQUEST);
				TXENQ(INVALID_REQUEST);
				break;
			}				

		case 181:		//RAM page Read
			if (1) { 
				Data = (far unsigned char *)RAMCommAddr.s_form;
				TXENQ(*Data);
				Data++;
				TXENQ(*Data);
				Data++;
				TXENQ(*Data);
				Data++;
				TXENQ(*Data);
			}
			else {
				TXENQ_0xFFFF();
				TXENQ_0xFFFF();
				ResponseType = COMMAND_REJECTED;
				TXENQ(INVALID_REQUEST);
			}
			break;

		case 153:		//RAM Address
			if (1) { 
				TXENQ(RAMCommAddr.b_form.low);		//low byte
				TXENQ(RAMCommAddr.b_form.high);		//high byte
			}
			else {
				ResponseType = COMMAND_REJECTED;
				TXENQ(INVALID_REQUEST);
				TXENQ(INVALID_REQUEST);
			}
			break;
	

		case 155:		//production test protocol
			TXENQ(PRODUCTION_TEST_PROTOCOL&255);
			TXENQ(PRODUCTION_TEST_PROTOCOL/256);
			break;
		case 175:		//voltage data
			ResponseType = DATA_RETURNED;
			TXENQ(InputDataPointer);
			TXENQ(DataBuffer[InputDataPointer].b_form.low);
			TXENQ(DataBuffer[InputDataPointer].b_form.high);
			TXENQ(0);

			InputDataPointer++;
			if (InputDataPointer >= 200) InputDataPointer = 255;
			break;


		case 176:		//voltage data bulk
			ResponseType = DATA_RETURNED;
			TXENQ(InputDataPointer);
			for (tempvar0 = 0;tempvar0 < 30;tempvar0++) {
				TXENQ(DataBuffer[InputDataPointer].b_form.low);
				TXENQ(DataBuffer[InputDataPointer].b_form.high);
				InputDataPointer++;
			}
			if (InputDataPointer >= 200) InputDataPointer = 255;
			break;
		default:
			ResponseType = 0xFF;
			break;
		}
	}

//Set command:
	if (!USBQuery && RxBuffer[1] == 0x04 || \
		USBQuery && SetupPkt.bRequest == SET_REPORT) {

		//default response for set command:
		ResponseType = COMMAND_ACCEPTED;
		CommEcho2Bytes = false;
		CommEcho4Bytes = false;

		switch ((USBQuery?SetupPkt._byte[2]:RxBuffer[3])) {
			
//Production test commands
		case 150:		//NVR Write
			if (1 && !PIE2bits.EEIE) { 
//				DISABLE_ALL_INTERRUPTS();
//				EECounterB = 1;						//Number of bytes to write.
//				EEAddress = NVRCommAddr.b_form.low;	//EEPROM register starting address byte.
//				EEData = RcvPtr[0];					//First byte of data to write.
//				EE_PAGE_WRITE();
//				ENABLE_ALL_INTERRUPTS();
			}
			else ResponseType = COMMAND_REJECTED;
			Echo1Byte();				//respond with the data that was queried via RS232
			break;
			
		case 151:		//NVR Address
			if (1) { 
//				NVRCommAddr.b_form.low = RcvPtr[0];		//low byte
//				NVRCommAddr.b_form.high = RcvPtr[1];	//high byte
			}
			else ResponseType = COMMAND_REJECTED;
			Echo2Bytes();				//respond with the data that was queried via RS232
			break;
		case 152:		//RAM Write
			if (1) {
				*(far unsigned char *)RAMCommAddr.s_form = RcvPtr[0];
			}
			else ResponseType = COMMAND_REJECTED;
			Echo1Byte();				//respond with the data that was queried via RS232
			break;
	
		case 153:		//RAM Address
			if (1) { 
				RAMCommAddr.b_form.low = RcvPtr[0];		//low byte
				RAMCommAddr.b_form.high = RcvPtr[1];	//high byte
			}
			else ResponseType = COMMAND_REJECTED;
			Echo2Bytes();				//respond with the data that was queried via RS232
			break;
		case 154:		//Password write (starting with low byte)
			if (RcvPtr[0] == 0x42 && \
				RcvPtr[1] == 0x19 && \
				RcvPtr[2] == 0x6E && \
				RcvPtr[3] == 0x86) {
			}
			//don't report command rejected because it'll make it easy to break the password.
			Echo4Bytes();				//respond with the data that was queried via RS232
			break;
		case 156:		//ROM Write (not supported)
//Writing a single byte is not supported by the chip.
			ResponseType = COMMAND_REJECTED;
			Echo1Byte();				//respond with the data that was queried via RS232
			break;
	
		case 157:		//ROM Address
			if (1) { 
				ROMCommAddr.b_form.low = RcvPtr[0];		//low byte
				ROMCommAddr.b_form.high = RcvPtr[1];	//high byte
			}
			else ResponseType = COMMAND_REJECTED;
			Echo2Bytes();				//respond with the data that was queried via RS232
			break;
		default:
			ResponseType = 0xff;
			break;
		}
	}

	ENABLE_ALL_INTERRUPTS();

	if (ResponseType == 0xff) {
		TxBufPtr = 0;			//clear out buffer..
		return;
	}

	if (USBQuery) {
//no response or ack?
		if (SetupPkt.bRequest == SET_REPORT) return;		//no response to set_report

		//USB query setup data:
		CtrlTrfData._byte[0] = SetupPkt._byte[2];
		wCount._word = USBDataPointer;		//Calculate number of bytes to send
		return;
	}
	else {

		//See the macros above Echo4Bytes() - they are used to set these flags:
		if (RxBuffer[1] == 0x04) {		//only if this is a set command..
			if (CommEcho4Bytes) {
				TXENQ(RcvPtr[0]);
				TXENQ(RcvPtr[1]);
				TXENQ(RcvPtr[2]);
				TXENQ(RcvPtr[3]);
			} 
			else if (CommEcho2Bytes) {
				TXENQ(RcvPtr[0]);
				TXENQ(RcvPtr[1]);
			}
			else {					//CommEcho1Byte doesn't exist - it is only active it 2 and 4 are not.
				TXENQ(RcvPtr[0]);
			}
		}

		//RS232 query setup data:
		TxBuffer[0] = HEADER_CHAR;
		TxBuffer[1] = ResponseType;
		TxBuffer[3] = RxBuffer[3];				//report ID.

		if (!SendingOutString) TxBuffer[2] = TxBufPtr-3;			//calculate the length of data returned
		//else TxBuffer[2] already written

		//if we've enqueued a byte, this indicates that the command was accepted.
		//In that case, we should compute the checksum and send the data out.
		if (!SendingOutString) {
			if (TxBufPtr > 2) {		
			//We've enqueued all other bytes, so write the checksum:
				tempvar0 = 0;
				for (tempvar1 = 0;tempvar1 < TxBufPtr;tempvar1++) {
					tempvar0 += TxBuffer[tempvar1];
				}
				TXENQ(tempvar0);			//enqueue checksum as final byte to send out.
				return;		//and exit
			}
		}
		//If the type of command received is neither a poll nor set command, 
		//or we dont recognize the reportID, cancel the command because it 
		//is not recognized.
		TildeFlg = false;					//reset colon-received flag.
		RxBufPtr = 0;						//Reset buffer.
		CmdLength = 0;
	}
	return;
}
